<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>EndlessWiki Constellation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { margin: 0; font-family: "Helvetica Neue","Helvetica","Arial",sans-serif; background: #0b1026; color: #f8f8ff; }
    header { padding: 16px 24px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; }
    header h1 { margin: 0; font-size: 20px; }
    header a { color: #89c2ff; text-decoration: none; }
    #meta { font-size: 13px; color: rgba(255,255,255,0.7); }
    #canvas { display: block; width: 100vw; height: calc(100vh - 72px); }
    #tooltip { position: fixed; pointer-events: none; background: rgba(11,16,38,0.9); color: #fff; padding: 6px 10px; border-radius: 4px; font-size: 12px; border: 1px solid rgba(255,255,255,0.2); display: none; }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>EndlessWiki Constellation</h1>
      <div id="meta">Loading constellation…</div>
    </div>
    <a href="/wiki/main_page">Back to EndlessWiki</a>
  </header>
  <canvas id="canvas"></canvas>
  <div id="tooltip"></div>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const meta = document.getElementById('meta');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - 72;
      if (nodes.length) {
        computeLayout();
        draw();
      }
    }

    window.addEventListener('resize', resize);

    let graph = { nodes: [], edges: [] };
    let nodes = [];
    let edges = [];

    fetch('/static/constellation.json')
      .then((res) => {
        if (!res.ok) throw new Error('Failed to load constellation data');
        return res.json();
      })
      .then((data) => {
        graph = data;
        meta.textContent = `Generated ${new Date(data.generated_at).toLocaleString()} · ${data.nodes.length} pages · ${data.edges.length} links`;
        prepareGraph();
        resize();
      })
      .catch((err) => {
        console.error(err);
        meta.textContent = 'Unable to load constellation data.';
      });

    function prepareGraph() {
      nodes = graph.nodes.map((node) => ({
        ...node,
        createdAt: new Date(node.created_at),
        r: 3 + Math.min(node.outbound, 30) * 0.35,
        x: 0,
        y: 0,
      }));

      const nodeMap = new Map(nodes.map((n) => [n.slug, n]));
      edges = graph.edges
        .map((edge) => {
          const source = nodeMap.get(edge.source);
          const target = nodeMap.get(edge.target);
          if (!source || !target) return null;
          return { ...edge, _source: source, _target: target };
        })
        .filter(Boolean);
    }

    function computeLayout() {
      if (!nodes.length) return;
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const baseRadius = Math.max(Math.min(width, height) * 0.06, 80);
      const ringSpacing = Math.max(Math.min(width, height) * 0.09, 110);

      const adjacency = new Map();
      edges.forEach((edge) => {
        if (!adjacency.has(edge.source)) adjacency.set(edge.source, new Set());
        if (!adjacency.has(edge.target)) adjacency.set(edge.target, new Set());
        adjacency.get(edge.source).add(edge.target);
        adjacency.get(edge.target).add(edge.source);
      });

      const levelMap = new Map();
      let nextLevel = 0;

      function bfs(seedSlug) {
        if (!seedSlug || levelMap.has(seedSlug)) return;
        const queue = [seedSlug];
        levelMap.set(seedSlug, nextLevel);
        while (queue.length) {
          const slug = queue.shift();
          const currentLevel = levelMap.get(slug);
          const neighbors = adjacency.get(slug);
          if (!neighbors) continue;
          neighbors.forEach((neighbor) => {
            if (!levelMap.has(neighbor)) {
              levelMap.set(neighbor, currentLevel + 1);
              queue.push(neighbor);
            }
          });
        }
        nextLevel = Math.max(...levelMap.values()) + 1;
      }

      const nodeMap = new Map(nodes.map((n) => [n.slug, n]));
      if (nodeMap.has('main_page')) {
        bfs('main_page');
      }

      const sortedNodes = nodes
        .slice()
        .sort((a, b) => a.createdAt - b.createdAt);

      sortedNodes.forEach((node) => {
        bfs(node.slug);
      });

      const levels = new Map();
      nodes.forEach((node) => {
        const level = levelMap.get(node.slug) ?? nextLevel++;
        levelMap.set(node.slug, level);
        if (!levels.has(level)) levels.set(level, []);
        levels.get(level).push(node);
      });

      Array.from(levels.keys())
        .sort((a, b) => a - b)
        .forEach((level) => {
          const group = levels.get(level);
          group.sort((a, b) => a.createdAt - b.createdAt);
          if (level === 0) {
            group[0].x = centerX;
            group[0].y = centerY;
            return;
          }

          const radius = baseRadius + (level - 1) * ringSpacing;
          const angleStep = (Math.PI * 2) / group.length;
          const startAngle = level * 0.42;
          group.forEach((node, index) => {
            const angle = startAngle + index * angleStep;
            node.x = centerX + radius * Math.cos(angle);
            node.y = centerY + radius * Math.sin(angle);
          });
        });
    }

    function draw() {
      if (!nodes.length) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'rgba(137, 194, 255, 0.12)';
      ctx.lineWidth = 1;
      edges.forEach((edge) => {
        ctx.beginPath();
        ctx.moveTo(edge._source.x, edge._source.y);
        ctx.lineTo(edge._target.x, edge._target.y);
        ctx.stroke();
      });

      nodes.forEach((node) => {
        ctx.beginPath();
        ctx.fillStyle = '#89c2ff';
        ctx.shadowColor = '#1a3c7c';
        ctx.shadowBlur = 12;
        ctx.arc(node.x, node.y, node.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }

    function findNodeAt(x, y) {
      for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        const dx = node.x - x;
        const dy = node.y - y;
        if (Math.sqrt(dx * dx + dy * dy) <= node.r + 3) {
          return node;
        }
      }
      return null;
    }

    canvas.addEventListener('mousemove', (event) => {
      if (!nodes.length) return;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const hit = findNodeAt(x, y);
      if (hit) {
        tooltip.style.display = 'block';
        tooltip.style.left = `${event.clientX + 12}px`;
        tooltip.style.top = `${event.clientY + 12}px`;
        tooltip.textContent = `${hit.slug} · outbound links: ${hit.outbound}`;
      } else {
        tooltip.style.display = 'none';
      }
    });

    canvas.addEventListener('click', (event) => {
      if (!nodes.length) return;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const hit = findNodeAt(x, y);
      if (hit) {
        window.location.href = `/wiki/${encodeURIComponent(hit.slug)}`;
      }
    });
  </script>
</body>
</html>
